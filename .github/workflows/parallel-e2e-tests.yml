name: Parallel E2E Tests

on:
  workflow_dispatch:
  push:
    branches: [main]
    paths:
      - '.github/workflows/parallel-e2e-tests.yml'
      - 'frontend/e2e/**'
      - 'frontend/src/**'
      - 'src/**'
      - 'k8s/**'
  schedule:
    - cron: '0 2 * * *' # Daily at 2am UTC

jobs:
  # Tests en parallÃ¨le - chaque fichier de test dans un job sÃ©parÃ©
  # Note: Chaque job exÃ©cute un fichier de test spÃ©cifique pour parallÃ©liser l'exÃ©cution
  run-all-tests:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        test-suite:
          - { name: 'user-management', file: 'user-management.spec.ts' }
          - { name: 'api-integration', file: 'api-integration.spec.ts' }
          - { name: 'form-validation', file: 'form-validation.spec.ts' }
          - { name: 'ui-ux', file: 'ui-ux.spec.ts' }
          - { name: 'performance', file: 'performance.spec.ts' }
          - { name: 'accessibility', file: 'accessibility.spec.ts' }
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create Kind cluster
        uses: helm/kind-action@v1
        with:
          version: v0.20.0
          cluster_name: kind
          wait: 5m

      - name: Verify cluster
        run: |
          kubectl cluster-info
          kubectl get nodes
          echo "Cluster name: $(kind get clusters)"

      - name: Install NGINX Ingress
        run: |
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=120s

      - name: Deploy Infrastructure
        run: |
          # PostgreSQL
          kubectl apply -f k8s/postgres-secret.yaml
          kubectl apply -f k8s/postgres-config.yaml
          kubectl apply -f k8s/postgres-deployment.yaml
          kubectl apply -f k8s/postgres-service.yaml
          kubectl wait --for=condition=ready pod -l app=postgres --timeout=180s
          
          # Swagger secret
          kubectl apply -f k8s/swagger-secret.yaml
          
          # Initialize DB
          kubectl apply -f k8s/reset-sql-config.yaml
          kubectl apply -f k8s/db-reset-job.yaml
          kubectl wait --for=condition=complete job/db-reset-job --timeout=120s || {
            echo "âŒ DB reset failed"
            kubectl logs job/db-reset-job
            exit 1
          }

      - name: Build and Load Docker Images
        run: |
          # Build and load API image
          echo "ðŸ—ï¸ Building API image..."
          docker build -t mini-api:latest .
          echo "ðŸ“¦ Loading API image into Kind cluster..."
          kind load docker-image mini-api:latest --name kind
          
          echo "ðŸ—ï¸ Building Frontend image..."
          cd frontend
          docker build -t mini-api-frontend:latest .
          echo "ðŸ“¦ Loading Frontend image into Kind cluster..."
          kind load docker-image mini-api-frontend:latest --name kind
          cd ..
          
          echo "âœ… Images loaded successfully"
          docker images | grep mini-api
          
          # Verify images are available in Kind
          echo "ðŸ” Verifying images in Kind cluster..."
          docker exec kind-control-plane crictl images | grep mini-api || {
            echo "âš ï¸ Warning: Images might not be visible in Kind yet"
          }

      - name: Deploy API
        run: |
          echo "ðŸš€ Deploying API..."
          kubectl apply -f k8s/api-deployment.yaml
          kubectl apply -f k8s/api-service.yaml
          
          echo "â³ Waiting for API pod to be ready..."
          kubectl wait --for=condition=ready pod -l app=mini-api --timeout=300s || {
            echo "âŒ API deployment failed"
            kubectl get deployments
            kubectl get pods -l app=mini-api
            kubectl describe pod -l app=mini-api | tail -50
            kubectl logs -l app=mini-api --tail=50 || echo "No logs available"
            exit 1
          }

      - name: Deploy Frontend
        run: |
          echo "ðŸš€ Deploying Frontend..."
          kubectl apply -f k8s/frontend-deployment.yaml
          kubectl apply -f k8s/frontend-service.yaml
          
          echo "â³ Waiting for Frontend pod to be ready..."
          kubectl wait --for=condition=ready pod -l app=mini-api-frontend --timeout=300s || {
            echo "âŒ Frontend deployment failed"
            kubectl get deployments
            kubectl get pods -l app=mini-api-frontend
            kubectl describe pod -l app=mini-api-frontend | tail -50
            kubectl logs -l app=mini-api-frontend --tail=50 || echo "No logs available"
            exit 1
          }
          
          # Setup Ingress
          kubectl apply -f k8s/frontend-ingress.yaml
          sleep 30

      - name: Configure DNS
        run: |
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          echo "$NODE_IP mini-api.local" | sudo tee -a /etc/hosts

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: frontend
        run: npm ci

      - name: Install Playwright Browsers
        working-directory: frontend
        run: npx playwright install --with-deps chromium

      - name: Run Tests - ${{ matrix.test-suite.name }}
        working-directory: frontend
        env:
          PLAYWRIGHT_JSON_OUTPUT_NAME: test-results-${{ matrix.test-suite.name }}.json
        run: npx playwright test ${{ matrix.test-suite.file }} --reporter=list,allure-playwright
        continue-on-error: true

      - name: Upload Allure results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: allure-results-${{ matrix.test-suite.name }}
          path: frontend/allure-results/
          retention-days: 7

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.test-suite.name }}
          path: |
            frontend/test-results-${{ matrix.test-suite.name }}.json
            frontend/test-results/
            frontend/playwright-report/
          retention-days: 7

  # Job pour gÃ©nÃ©rer le rapport Allure consolidÃ©
  generate-allure-report:
    needs: run-all-tests
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Java (required for Allure)
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Download all Allure results
        uses: actions/download-artifact@v4
        with:
          pattern: allure-results-*
          path: allure-results-temp/

      - name: Merge Allure results
        run: |
          mkdir -p allure-results
          echo "ðŸ“¦ Merging Allure results from all test suites..."
          find allure-results-temp -type f -name "*.json" -exec cp {} allure-results/ \;
          find allure-results-temp -type f -name "*.txt" -exec cp {} allure-results/ \;
          find allure-results-temp -type f -name "*.png" -exec cp {} allure-results/ \;
          echo "âœ… Found $(ls -1 allure-results | wc -l) result files"
          ls -la allure-results/

      - name: Generate Allure report
        run: |
          npm install -g allure-commandline
          allure generate allure-results --clean -o allure-report
          echo "âœ… Allure report generated"

      - name: Upload Allure report
        uses: actions/upload-artifact@v4
        with:
          name: allure-report
          path: allure-report/
          retention-days: 30

      - name: Add report link to summary
        run: |
          echo "## ðŸ“Š Test Reports" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Allure report generated successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“¥ Download the artifact 'allure-report' and open 'index.html' locally" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Or use: \`npx allure open allure-report\`" >> $GITHUB_STEP_SUMMARY
