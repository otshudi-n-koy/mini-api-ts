name: Parallel E2E Tests

on:
  workflow_dispatch:
  push:
    branches: [main]
    paths:
      - '.github/workflows/parallel-e2e-tests.yml'
      - 'frontend/e2e/**'
      - 'frontend/src/**'
      - 'src/**'
      - 'k8s/**'
  schedule:
    - cron: '0 2 * * *' # Daily at 2am UTC

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  # Tests en parallÃ¨le - chaque fichier de test dans un job sÃ©parÃ©
  # Note: Chaque job exÃ©cute un fichier de test spÃ©cifique pour parallÃ©liser l'exÃ©cution
  run-all-tests:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        test-suite:
          - { name: 'form-validation', file: 'form-validation.spec.ts' }
          - { name: 'user-management', file: 'user-management.spec.ts' }
          - { name: 'api-integration', file: 'api-integration.spec.ts' }
          - { name: 'ui-ux', file: 'ui-ux.spec.ts' }
          - { name: 'performance', file: 'performance.spec.ts' }
          - { name: 'accessibility', file: 'accessibility.spec.ts' }
          - { name: 'authentication', file: 'authentication.spec.ts' }
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create Kind cluster
        uses: helm/kind-action@v1
        with:
          version: v0.20.0
          cluster_name: kind
          wait: 5m

      - name: Verify cluster
        run: |
          kubectl cluster-info
          kubectl get nodes
          echo "Cluster name: $(kind get clusters)"

      - name: Install NGINX Ingress
        run: |
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=120s

      - name: Deploy Infrastructure
        run: |
          # PostgreSQL
          kubectl apply -f k8s/postgres-secret.yaml
          kubectl apply -f k8s/postgres-config.yaml
          kubectl apply -f k8s/postgres-deployment.yaml
          kubectl apply -f k8s/postgres-service.yaml
          kubectl wait --for=condition=ready pod -l app=postgres --timeout=180s
          
          # Swagger secret
          kubectl apply -f k8s/swagger-secret.yaml
          
          # Initialize DB
          kubectl apply -f k8s/reset-sql-config.yaml
          kubectl apply -f k8s/db-reset-job.yaml
          kubectl wait --for=condition=complete job/db-reset-job --timeout=120s || {
            echo "âŒ DB reset failed"
            kubectl logs job/db-reset-job
            exit 1
          }

      - name: Build and Load Docker Images
        run: |
          # Build and load API image
          echo "ðŸ—ï¸ Building API image..."
          docker build -t mini-api:latest .
          echo "ðŸ“¦ Loading API image into Kind cluster..."
          kind load docker-image mini-api:latest --name kind
          
          echo "ðŸ—ï¸ Building Frontend image..."
          cd frontend
          docker build -t mini-api-frontend:latest .
          echo "ðŸ“¦ Loading Frontend image into Kind cluster..."
          kind load docker-image mini-api-frontend:latest --name kind
          cd ..
          
          echo "âœ… Images loaded successfully"
          docker images | grep mini-api
          
          # Verify images are available in Kind
          echo "ðŸ” Verifying images in Kind cluster..."
          docker exec kind-control-plane crictl images | grep mini-api || {
            echo "âš ï¸ Warning: Images might not be visible via crictl yet, checking with kubectl..."
          }
          
          # Wait a moment for images to be fully available
          sleep 5

      - name: Deploy API
        run: |
          echo "ðŸš€ Deploying API..."
          kubectl apply -f k8s/api-deployment.yaml
          kubectl apply -f k8s/api-service.yaml
          
          echo "â³ Waiting for API pod to be ready..."
          kubectl wait --for=condition=ready pod -l app=mini-api --timeout=300s || {
            echo "âŒ API deployment failed"
            echo "ðŸ“‹ Deployment status:"
            kubectl get deployments
            echo "ðŸ“‹ Pod status:"
            kubectl get pods -l app=mini-api
            echo "ðŸ“‹ Pod details:"
            kubectl describe pod -l app=mini-api | tail -100
            echo "ðŸ“‹ Available images in Kind:"
            docker exec kind-control-plane crictl images | grep mini-api || echo "No mini-api images found"
            echo "ðŸ“‹ Pod logs (if available):"
            kubectl logs -l app=mini-api --tail=50 || echo "No logs available"
            exit 1
          }
          
          echo "âœ… API pod is ready"
          echo "ðŸ” Verifying API health..."
          API_POD=$(kubectl get pod -l app=mini-api -o jsonpath='{.items[0].metadata.name}')
          kubectl exec $API_POD -- wget -qO- http://localhost:3000/api/v1/health || {
            echo "âš ï¸ API health check failed, but pod is running"
          }

      - name: Deploy Frontend
        run: |
          echo "ðŸš€ Deploying Frontend..."
          kubectl apply -f k8s/frontend-deployment.yaml
          kubectl apply -f k8s/frontend-service.yaml
          
          echo "â³ Waiting for Frontend pod to be ready..."
          kubectl wait --for=condition=ready pod -l app=mini-api-frontend --timeout=300s || {
            echo "âŒ Frontend deployment failed"
            kubectl get deployments
            kubectl get pods -l app=mini-api-frontend
            kubectl describe pod -l app=mini-api-frontend | tail -50
            kubectl logs -l app=mini-api-frontend --tail=50 || echo "No logs available"
            exit 1
          }
          
          # Setup Ingress
          kubectl apply -f k8s/frontend-ingress.yaml
          sleep 30

      - name: Configure DNS
        run: |
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          echo "$NODE_IP mini-api.local" | sudo tee -a /etc/hosts

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: frontend
        run: npm ci

      - name: Install Playwright Browsers
        working-directory: frontend
        run: npx playwright install --with-deps chromium

      - name: Run Tests - ${{ matrix.test-suite.name }}
        working-directory: frontend
        env:
          PLAYWRIGHT_JSON_OUTPUT_NAME: test-results-${{ matrix.test-suite.name }}.json
        run: npx playwright test ${{ matrix.test-suite.file }} --reporter=list,allure-playwright
        continue-on-error: true

      - name: Upload Allure results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: allure-results-${{ matrix.test-suite.name }}
          path: frontend/allure-results/
          retention-days: 7

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.test-suite.name }}
          path: |
            frontend/test-results-${{ matrix.test-suite.name }}.json
            frontend/test-results/
            frontend/playwright-report/
          retention-days: 7

  # Job pour gÃ©nÃ©rer le rapport Allure consolidÃ©
  generate-allure-report:
    needs: run-all-tests
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Java (required for Allure)
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Download all Allure results
        uses: actions/download-artifact@v4
        with:
          pattern: allure-results-*
          path: allure-results-temp/

      - name: Get Allure history
        uses: actions/checkout@v4
        if: always()
        continue-on-error: true
        with:
          ref: gh-pages
          path: gh-pages

      - name: Merge Allure results
        run: |
          mkdir -p allure-results
          echo "ðŸ“¦ Merging Allure results from all test suites..."
          find allure-results-temp -type f -name "*.json" -exec cp {} allure-results/ \;
          find allure-results-temp -type f -name "*.txt" -exec cp {} allure-results/ \;
          find allure-results-temp -type f -name "*.png" -exec cp {} allure-results/ \;
          find allure-results-temp -type f -name "*.properties" -exec cp {} allure-results/ \;
          echo "âœ… Found $(ls -1 allure-results | wc -l) result files"
          ls -la allure-results/
          echo "ðŸ“‹ Executor file check:"
          cat allure-results/executor.json 2>/dev/null || echo "âš ï¸ No executor.json found"

      - name: Copy Allure history
        if: always()
        continue-on-error: true
        run: |
          echo "ðŸ“œ Copying Allure history from previous reports..."
          mkdir -p allure-results/history
          if [ -d "gh-pages/allure-report/history" ]; then
            cp -r gh-pages/allure-report/history/* allure-results/history/
            echo "âœ… History copied successfully"
            ls -la allure-results/history/
          else
            echo "â„¹ï¸ No previous history found (first run or history cleared)"
          fi

      - name: Create executor.json
        if: always()
        run: |
          cat > allure-results/executor.json <<EOF
          {
            "name": "GitHub Actions",
            "type": "github",
            "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "buildOrder": ${{ github.run_number }},
            "buildName": "${{ github.workflow }} #${{ github.run_number }}",
            "buildUrl": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "reportUrl": "https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/allure-report/",
            "reportName": "Allure Report - ${{ github.ref_name }}"
          }
          EOF
          echo "âœ… Executor metadata created"
          cat allure-results/executor.json

      - name: Create environment.properties
        if: always()
        run: |
          cat > allure-results/environment.properties <<EOF
          Browser=Chromium
          Node.Version=20
          OS=${{ runner.os }}
          Runner=ubuntu-latest
          Repository=${{ github.repository }}
          Branch=${{ github.ref_name }}
          Commit=${{ github.sha }}
          Author=${{ github.actor }}
          Run.ID=${{ github.run_id }}
          Run.Number=${{ github.run_number }}
          Workflow=${{ github.workflow }}
          Kubernetes=Kind
          Test.Framework=Playwright
          EOF
          echo "âœ… Environment metadata created"
          cat allure-results/environment.properties

      - name: Generate Allure report
        run: |
          npm install -g allure-commandline
          allure generate allure-results --clean -o allure-report
          echo "âœ… Allure report generated with history"

      - name: Upload Allure report
        uses: actions/upload-artifact@v4
        with:
          name: allure-report
          path: allure-report/
          retention-days: 30

      - name: Deploy Allure report to GitHub Pages
        if: github.ref == 'refs/heads/main'
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./allure-report
          destination_dir: allure-report
          keep_files: false
          commit_message: 'docs: Update Allure test report'

      - name: Add report link to summary
        run: |
          echo "## ðŸ“Š Test Reports" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Allure report generated successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "ðŸŒ **Live Report:** https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/allure-report/" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          echo "ðŸ“¥ Download the artifact 'allure-report' and open 'index.html' locally" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Or use: \`npx allure open allure-report\`" >> $GITHUB_STEP_SUMMARY
